Tudor Cristian-Andrei 311CA

Programarea Calculatoarelor si Limbaje de Programare - Tema 1

Problema 1 - Un produs infinit

	Pentru aceasta problema numerele se citeau in baza 8, asa ca am optat sa le transform din baza 8 in baza 10 pentru a lucra cu ele prin functia convert_octal_to_decimal, in care este implementat algoritmul matematic de transformare a unui numar din baza 8 in baza 10. Pentru acesta am folosit si functia pow din biblioteca math.h. Functia ia fiecare cifra a numarului si o inmulteste cu 8 la puterea p, care pleaca de la 0 si este incrementat, ajungand pana la k - 1, unde k este numarul de cifre al numarului dat in baza 8.
	In functia main am luat 7 variabile, n care reprezinta nuamrul de cifre ce urmeaza a fi citite, i - ul care parcurge intervalul de la 1 la n, pentru a citi exact n numere, ai si bi, numerele care se citesc, ps, care reprezinta produsul scalar, a_max si b_max, si a_second_max si b_second_max, care memoreaza maximul si al doilea maxim. Variabilele n_a si n_b sunt pentru norma lui a si norma lui b. 
	Citesc de n - ori numerele ai si bi, dupa care se convertesc in baza 10. Verific de fiecare data daca ai si bi (verific separat pentru fiecare)sunt mai mari decat al doilea maxim si mai mic de maximele, caz in care doar al doilea maxim se schimba, sau daca ai si bi (verific separat pentru fiecare) sunt mai mari decat maximele, caz in care se schimba si maximele si al doilea maxim. Al doilea maxim ia valoarea maximului, iar maximul ia valoarea lui ai, respectiv bi. Adun de fiecare la produsul scalar, initializat cu 0, produsul dintre ai si bi. Analog si pentru norme, unde adun patratul lui ai, respectiv patratul lui bi, dar convertit in tipul unsingned long long, deoarece pentru numere mai mari ai * ai sau bi * bi depaseste tipul long long.
	In final, printez ps - ul calculat in for, valorile lui a_second_max si b_second_max, si radicalul lui n_a si n_b, folosind functia sqrt din biblioteca math.h. 

Problema 2 - Simple query pe litere 

	Pentru aceasta problema am folosit mai multe functii. In main am declarart un caracter ltr (de la "letter"), un vector de frecventa freq (de la frequency), pe care l - am initializat cu 0, si un vector ascii, care imi memoreaza ce litera se afla pe pozitia i in vectorul de frecventa, prin memorarea codului ascii a tuturor literelor de la a la z. Pe acesta l - am initializat cu functia initialize_ascii, care retine la inceput literele alfabetului in ordine, plecand de la 0, astfel incat pentru 0 ii corespunde a, pentru 1 ii corespunde b, ... pentru 25 ii corespunde z. Atat vectorul de frecventa cat si vectorul ascii sunt de 27 de elemente, dar niciodata nu il foloseste pe al 27 - lea, cu indicele 26. Mai am luat alte 2 variabile, n, care retine numarul total de litere, si ok_alert care retine daca au fost introduse cel putin 5 litere de la alerta precedenta. Dupa initializari citesc prima litera, si adaug 1 la numarul total de litere, ok_alert, si la vectorul de frecventa. Fiind prima litera, asupra vectorului de frecventa nu s - au facut modificari asa ca pot sa folosesc pentru index ltr - 97, care va da indicele corespunzator literei, asa cum le - am atribuit initial (0 pentru a , 1 pentru b, ..., 25 pentru z). 
	Functia islwr returneaza valoarea 1 daca litera este o litera mica, si 0 daca nu este, iar functia isqrry returneaza valoarea 1 daca litera introdusa este una dintre cele folosite pentru interogari, Q, T, sau E, sau 0, daca litera este diferita de Q, T sau E. 
	Astfel, cat timp ce introducem de la tastatura este un caracter valid, fie el litera mica, sau litera folosita la interogare, vom continua executia programului. 
	Datorita interogarii cu T, vectorii nu or sa aiba mereu aceeasi ordine, asa ca e nevoie sa cautam de fiecare data pe ce pozitie se afla o anumita litera. Astfel functia find_element cauta o litera data de la tastatura in vectorul ascii, si returneaza pozitia i, la care se afla.
	Functia delete_element primeste ca parametrii o litera (pe care dorim sa o stergem), vectorul ascii, si vectorul de frecventa. Functioneaza pe acelasi principiu ca functia find_element, doar ca atunci cand gaseste pozitia i, reinitializeaza cu 0 elementul de la pozitia i din vectorul de frecventa.
	Functia sort_frequency sorteaza atat vectorul de frecventa cat si vectorul "ascii", dupa numarul de aparitii (prin metoda selection sort). Astfel, cand face o mutare in vectorul de frecventa o face si in vectorul ascii.
	Functia sort_alpha trebuie apelata dupa sort_freq, astfel incat, dupa ce s - au sortat literele in functie de frecventa lor, pe pozitiile in care frecventa este egala, literele vor fi sortate alfabetic (codurile ascii trebuie sortate crescator).
	Functia diff verifica daca in vector apar cel putin 2 elemente diferite. Daca exista returneaza 1, altfel returneaza 0. 
	Functia cmmdc calculeaza cel mai mic divizor comun prin scaderi repetate.
	In functia principala se citesc caractere, pana este introdus unul invalid (diferit de literele de la a la z, Q, T sau E). Daca litera introdusa este E se asteapta un spatiu cu functia getchar, dupa care introducerea unei noi litere, memorate in variabila locala e_input. Se cauta pozitia in cei doi vectori a caracterului cu ajutorul functiei find_element, dupa care se sterge numarul de aparitii din totalul literelor, retinut in n, dupa care se sterge numarul de aparitii cu functia delete_element (s - ar fi putut folosi rezultatul obtinut anterior din functia find_element).
	Daca litera introdusa este Q, se asteapta un spatiu cu functia getchar, dupa care introducerea unei alte litere, memorate in variabila locala q_input. Se apeleaza functia find_element pentru a afla pozitia literei in cei 2 vectori, dupa care se afiseaza pe ecran valoarea din vectorul de frecventa corespunzatoare literei.
	Daca litera introdusa este T, se asteapta un spatiu si introducerea unei cifre k, se ordoneaza vectorul cu functia sort_frequency, dupa cu functia sort_alpha, si se afiseaza pe ecran primele k elemente din vectorul ordonat (din cel ascii, care retine codul). 
	La final, dupa citirea unei noi litere, se verifica daca trebuie afisata o alerta. Prima data verifica daca au trecut mai mult de 5 caractere de la ultima alerta si daca exista cel putin 2 litere diferite introduse. Daca se indeplineste conditia, verifica daca vreuna din litere a aparut mai mult de 50% din totalul de caractere introduse. Atunci afiseaza pe ecran fractia in forma ireductibila, pe care o face cu ajutorul cmmdc. Variabila ok_alert ia din nou valoarea 0 dupa afisarea unei alerte.


Problema 3 - Gigel si tabla de sah 
	
	Pentru aceasta problema am folosit mai multe functii. 
	Functia read_matrix primeste ca parametrii matricea m si un numar natural n, si citeste o matrice cu n linii si n coloane.
	Functia type este folosita pentru a determina daca un element al matricei reprezinta patratel negru sau patratel alb pe tabla de sah. Astfel patratelul alb este reprezentat de valoarea 1, iar cel negru de valoarea -1.
	Functia how_many_times afla de cate ori un numar este cuprins in alt numar (de cate ori se imparte n la k). 
	Functia metoda_excel este folosita pentru a afisa coloanele asa cum cere problema. Astfel am luat 3 cazuri. Cel mai simplu caz, cand x este mai mic decat 26, si trebuie afisata o singura litera. Pentru ca x pleaca de la 0, am asociat fiecaruia codul ascii prin adunarea cu 65 (deoarce prima litera mare in ascii este 65, astfel pentru 0 va afisa A, pentru 1 va afisa B (1 + 65 = 66 = B in ascii) si tot asa). Al doilea caz este cand grupul de litere ce trebuie afisat este format din 2 litere. Pt fiecare litera avem 26 de posibilitati, asa ca in acest caz mergem pana la 26 * 26. La inceputul functiei am initializat un vector v cu codurile ascii ale literelor de la A pana la Z, care ne va folosi acum. Prin teste matematice efectuate pe hartie am aflat ca litera pe care trebuie sa o afisez a doua este data de restul impartirii lui x la 26. Prima litera este data de numarul dinaintea virgulei, rezultat prin impartirea lui x la 26. Astfel daca 26 este cuprins o singura data in x, vom afisa A, adica v[0], daca este cuprins de 2 ori vom afisa B, adica v[1], si tot asa. Cazul pentru 3 litere ce trebuie afisate este similar, dar de data asta tinem cont si de cate ori este cuprins 26 * 26 in x. (x fiind mai mare sau egal cu 26 * 26). 
	In functia principala am luat un vector ticket, care retine valorile scrise pe bilete de catre Gigel, un n care retine ce dimensiune are tabla de sah, i si j folositi pentru parcurgere, dist folosit pentru a calcula distanta parcursa, si pion care trece de pe o patratica pe alta.
	Cat timp pionul nu se afla pe o casuta pe care este scris 0, se executa mutarile aferente. Am impartit problema in 4 cazuri aferente, cand este pe alb si numarul este pozitiv, cand este pe alb si numarul este negativ, cand este pe negru si este pozitiv si cand este pe negru si este pozitiv. 
	Cazurile sunt similare, 2 cate 2. In toate cazurile, prima data am luat restul impartirii valorii absolute a numarului de pe bilet la dimensiunea tablei de sah (am facut ascest lucru, pentru ca, in cazul in care numarul este destul de mare fata de dimiensiunea tablei de sah, pionul va trece de mai multe ori prin aceleasi locuri, fiind o structura toroidala), valoare pe care am memorat - o in variabila rest. De fiecare data adun la distanta valoarea absoluta a numarului, dist fiind initial egala cu 0. Dupa aceste operatii, patratelul devine un patratel pe care pionul a fost deja, deci se face 0. Dupa acestea se executa mutarile aferente fiecarui caz in parte (si mutarile sunt luate pe mai multe cazuri : cazul in care se poate muta direct, sau pionul trebuie sa sara la celalalt capat al tablei). 
	La final pentru a afisa invers liniile, am facut o operatie simpla, n - i, iar pentru a afisa coloanele am folosit functia metoda_excel. 


Problema 4 - Queries again ...

	Pentru acesta problema am folosit 2 define - uri in plus, pentru a nu ma luni pe rand, sa depasesc limita de coding style. 
	Functia read_square_matrix citeste o matrice de tipul celei cerute de problema (de dimensiuni n * n pe n * n). 
	Pentru fiecare querry am facut functii separate, plus alte functii ajutatoare. 
	Pentru querry_one am folosit un vector ok, care daca are valoarea 0, inseamna ca cifra (de fapt cifra + 1, pentru ca vectorul incepe de la 0) de pe acea pozitie poate fi folosita, si daca are valoarea 1 inseamna ca acea cifra (again, cifra + 1) a fost deja folosita pe linie. Testez fiecare element de pe linia data cu toate numerele de la 1 la n * n, si schimb valoarea lui ok in 1, daca acea cifra a fost deja folosita.
	Pentru querry_two am folosit acelasi principiu numai ca de data acesta am cautat pe coloana, nu pe linie.
	Pentru al 3 -lea querry am folosit mai multe functii. In primul rand, pentru a parcurge careul, vreau sa ii aflu adresa de inceput (mai exact indici de la care incepe, de ex primu careu incepe de la 0 0, al doilea de la 0 3). Pentru aceasta operatie am folosit 2 functii, una care returneaza indicele liniei, get_line_start, si alta care returneaza indicele coloanei, get_column_start. Principiul pentru ambele este urmatorul : se parcurgea matricea cu cate n elemente odata pe linie, iar cand ajunge la sfarsit se parcurg cate n elemente pe coloana de odata. Functia get_square functioneaza invers, i se dau ca parametrii 2 coordonate x si y si afla in ce careu se gasesc. Parcurge fiecare careu dupa principiul enuntat mai sus, pana ii gaseste si pe x si pe y inclusi in careu.
	Functia querry_three functioneaza asemanator primelor 2, doar ca pargurge careul in loc de linie sau coloana, cu indicii de inceput obtinuti prin functiile descrise anterior.
	Pentru querry_four, vreau sa afisez acele elemente care nu sunt nici pe linia lui x, nici pe coloana lui y, nici in careul in care se afla perechea de coordonate x, y. Pentru primele 2 folosesc aceeasi tehnica ca la primele 2 interogari, iar pentru careu, intai apelez functia get_square, pentru a afla in ce careu se afla (x, y). Iau indicii de inceput ai careului aflat, si il parcurg. Daca in casuta descrisa de coordonatele x, y deja se afla ceva afisez de n ori pe 0, altfel afisez numerele  care nu s - au gasit in niciunul dintre linie, coloana, sau careu.
	Pentru a cincea interogare nu am avut nevoie de o functie separata intrucat doar verific daca patratelul este gol, adica egal cu 0, caz in care pot plasa numarul in patratel.
	Pentru querry_six salvez in cate o matrice frecventa numerelor pentru linii (se lucreaza cu 3 matrici separate), pentru coloane, si pentru careuri. In toate cazurile salvez frecventa pe linii, astfel : Pe linia 0 se gaseste frecventa pentru prima linie intr - o matrice, pentru prima coloana intr - o matrice si pentru primul careu intr - o matrice; Pe linia 1 se gaseste frecventa pentru a doua linie intr - o matrice , pentru a doua coloana intr - o matrice si pentru al 2 -lea careu intr - o matrice si tot asa. Dupa ce am facut frecventa, intai verific daca vreuna din numere apare de mai multe ori (de cel putin 2 ori) in vreunul din vectori. In acest caz returnez 1 care inseamna ca s - a ajuns intr - o configuratie invalida. Daca functia nu a returnat 1, se trece mai departe si se verifica daca exista vreo patratica necompletata. In acest caz returnez 0 care inseamna ca jocul poate fi continuat. Daca nu s - a returnat niciuna dintre valori, s - a ajuns la o configuratie valida, reprezentata prin valoarea 2.  